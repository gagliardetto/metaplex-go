// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package auction

import (
	"fmt"
	ag_binary "github.com/gagliardetto/binary"
	ag_solanago "github.com/gagliardetto/solana-go"
)

type AuctionData struct {
	// Pubkey of the authority with permission to modify this auction.
	Authority ag_solanago.PublicKey

	// Token mint for the SPL token being used to bid
	TokenMint ag_solanago.PublicKey

	// The time the last bid was placed, used to keep track of auction timing.
	LastBid *ag_solanago.UnixTimeSeconds `bin:"optional"`

	// Slot time the auction was officially ended by.
	EndedAt *ag_solanago.UnixTimeSeconds `bin:"optional"`

	// End time is the cut-off point that the auction is forced to end by.
	EndAuctionAt *ag_solanago.UnixTimeSeconds `bin:"optional"`

	// Gap time is the amount of time in slots after the previous bid at which the auction ends.
	EndAuctionGap *ag_solanago.UnixTimeSeconds `bin:"optional"`

	// Minimum price for any bid to meet.
	PriceFloor PriceFloor

	// The state the auction is in, whether it has started or ended.
	State AuctionState

	// Auction Bids, each user may have one bid open at a time.
	BidState BidState
}

func (obj AuctionData) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `Authority` param:
	err = encoder.Encode(obj.Authority)
	if err != nil {
		return err
	}
	// Serialize `TokenMint` param:
	err = encoder.Encode(obj.TokenMint)
	if err != nil {
		return err
	}
	// Serialize `LastBid` param (optional):
	{
		if obj.LastBid == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.LastBid)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `EndedAt` param (optional):
	{
		if obj.EndedAt == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.EndedAt)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `EndAuctionAt` param (optional):
	{
		if obj.EndAuctionAt == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.EndAuctionAt)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `EndAuctionGap` param (optional):
	{
		if obj.EndAuctionGap == nil {
			err = encoder.WriteBool(false)
			if err != nil {
				return err
			}
		} else {
			err = encoder.WriteBool(true)
			if err != nil {
				return err
			}
			err = encoder.Encode(obj.EndAuctionGap)
			if err != nil {
				return err
			}
		}
	}
	// Serialize `PriceFloor` param:
	{
		tmp := priceFloorContainer{}
		switch realvalue := obj.PriceFloor.(type) {
		case *None:
			tmp.Enum = 0
			tmp.None = *realvalue
		case *MinimumPrice:
			tmp.Enum = 1
			tmp.MinimumPrice = *realvalue
		case *BlindedPrice:
			tmp.Enum = 2
			tmp.BlindedPrice = *realvalue
		}
		err := encoder.Encode(tmp)
		if err != nil {
			return err
		}
	}
	// Serialize `State` param:
	err = encoder.Encode(obj.State)
	if err != nil {
		return err
	}
	// Serialize `BidState` param:
	{
		tmp := bidStateContainer{}
		switch realvalue := obj.BidState.(type) {
		case *EnglishAuction:
			tmp.Enum = 0
			tmp.EnglishAuction = *realvalue
		case *OpenEdition:
			tmp.Enum = 1
			tmp.OpenEdition = *realvalue
		}
		err := encoder.Encode(tmp)
		if err != nil {
			return err
		}
	}
	return nil
}

func (obj *AuctionData) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `Authority`:
	err = decoder.Decode(&obj.Authority)
	if err != nil {
		return err
	}
	// Deserialize `TokenMint`:
	err = decoder.Decode(&obj.TokenMint)
	if err != nil {
		return err
	}
	// Deserialize `LastBid` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.LastBid)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `EndedAt` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.EndedAt)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `EndAuctionAt` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.EndAuctionAt)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `EndAuctionGap` (optional):
	{
		ok, err := decoder.ReadBool()
		if err != nil {
			return err
		}
		if ok {
			err = decoder.Decode(&obj.EndAuctionGap)
			if err != nil {
				return err
			}
		}
	}
	// Deserialize `PriceFloor`:
	{
		tmp := new(priceFloorContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return err
		}
		switch tmp.Enum {
		case 0:
			obj.PriceFloor = &tmp.None
		case 1:
			obj.PriceFloor = &tmp.MinimumPrice
		case 2:
			obj.PriceFloor = &tmp.BlindedPrice
		default:
			return fmt.Errorf("unknown enum index: %v", tmp.Enum)
		}
	}
	// Deserialize `State`:
	err = decoder.Decode(&obj.State)
	if err != nil {
		return err
	}
	// Deserialize `BidState`:
	{
		tmp := new(bidStateContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return err
		}
		switch tmp.Enum {
		case 0:
			obj.BidState = &tmp.EnglishAuction
		case 1:
			obj.BidState = &tmp.OpenEdition
		default:
			return fmt.Errorf("unknown enum index: %v", tmp.Enum)
		}
	}
	return nil
}

type BidderMetadata struct {
	// Relationship with the bidder who's metadata this covers.
	BidderPubkey ag_solanago.PublicKey

	// Relationship with the auction this bid was placed on.
	AuctionPubkey ag_solanago.PublicKey

	// Amount that the user bid.
	LastBid uint64

	// Tracks the last time this user bid.
	LastBidTimestamp ag_solanago.UnixTimeSeconds

	// Whether the last bid the user made was cancelled. This should also be enough to know if the
	// user is a winner, as if cancelled it implies previous bids were also cancelled.
	Cancelled bool
}

func (obj BidderMetadata) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `BidderPubkey` param:
	err = encoder.Encode(obj.BidderPubkey)
	if err != nil {
		return err
	}
	// Serialize `AuctionPubkey` param:
	err = encoder.Encode(obj.AuctionPubkey)
	if err != nil {
		return err
	}
	// Serialize `LastBid` param:
	err = encoder.Encode(obj.LastBid)
	if err != nil {
		return err
	}
	// Serialize `LastBidTimestamp` param:
	err = encoder.Encode(obj.LastBidTimestamp)
	if err != nil {
		return err
	}
	// Serialize `Cancelled` param:
	err = encoder.Encode(obj.Cancelled)
	if err != nil {
		return err
	}
	return nil
}

func (obj *BidderMetadata) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `BidderPubkey`:
	err = decoder.Decode(&obj.BidderPubkey)
	if err != nil {
		return err
	}
	// Deserialize `AuctionPubkey`:
	err = decoder.Decode(&obj.AuctionPubkey)
	if err != nil {
		return err
	}
	// Deserialize `LastBid`:
	err = decoder.Decode(&obj.LastBid)
	if err != nil {
		return err
	}
	// Deserialize `LastBidTimestamp`:
	err = decoder.Decode(&obj.LastBidTimestamp)
	if err != nil {
		return err
	}
	// Deserialize `Cancelled`:
	err = decoder.Decode(&obj.Cancelled)
	if err != nil {
		return err
	}
	return nil
}

type BidderPot struct {
	// Points at actual pot that is a token account
	BidderPot ag_solanago.PublicKey

	// Originating bidder account
	BidderAct ag_solanago.PublicKey

	// Auction account
	AuctionAct ag_solanago.PublicKey

	// emptied or not
	Emptied bool
}

func (obj BidderPot) MarshalWithEncoder(encoder *ag_binary.Encoder) (err error) {
	// Serialize `BidderPot` param:
	err = encoder.Encode(obj.BidderPot)
	if err != nil {
		return err
	}
	// Serialize `BidderAct` param:
	err = encoder.Encode(obj.BidderAct)
	if err != nil {
		return err
	}
	// Serialize `AuctionAct` param:
	err = encoder.Encode(obj.AuctionAct)
	if err != nil {
		return err
	}
	// Serialize `Emptied` param:
	err = encoder.Encode(obj.Emptied)
	if err != nil {
		return err
	}
	return nil
}

func (obj *BidderPot) UnmarshalWithDecoder(decoder *ag_binary.Decoder) (err error) {
	// Deserialize `BidderPot`:
	err = decoder.Decode(&obj.BidderPot)
	if err != nil {
		return err
	}
	// Deserialize `BidderAct`:
	err = decoder.Decode(&obj.BidderAct)
	if err != nil {
		return err
	}
	// Deserialize `AuctionAct`:
	err = decoder.Decode(&obj.AuctionAct)
	if err != nil {
		return err
	}
	// Deserialize `Emptied`:
	err = decoder.Decode(&obj.Emptied)
	if err != nil {
		return err
	}
	return nil
}
